import { Injectable, Inject } from '@angular/core';
import { throwError, of, ReplaySubject } from 'rxjs';
import { mergeMap, catchError, tap } from 'rxjs/operators';
import { JSONValidator } from '../validation/json-validator';
import { IndexedDBDatabase } from '../databases/indexeddb-database';
import { LocalStorageDatabase } from '../databases/localstorage-database';
import { MemoryDatabase } from '../databases/memory-database';
import { IDB_BROKEN_ERROR } from '../databases/exceptions';
import { LS_PREFIX } from '../tokens';
import { ValidationError } from './exceptions';
import * as i0 from "@angular/core";
import * as i1 from "../databases/local-database";
import * as i2 from "../validation/json-validator";
export class StorageMap {
    /**
     * Constructor params are provided by Angular (but can also be passed manually in tests)
     * @param database Storage to use
     * @param jsonValidator Validator service
     * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain or for interoperability
     */
    constructor(database, jsonValidator = new JSONValidator(), LSPrefix = '') {
        this.database = database;
        this.jsonValidator = jsonValidator;
        this.LSPrefix = LSPrefix;
        this.notifiers = new Map();
    }
    /**
     * **Number of items** in storage, wrapped in an `Observable`.
     *
     * @example
     * this.storageMap.size.subscribe((size) => {
     *   console.log(size);
     * });
     */
    get size() {
        return this.database.size
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(() => this.database.size));
    }
    /**
     * Tells you which storage engine is used. *Only useful for interoperability.*
     * Note that due to some browsers issues in some special contexts
     * (Firefox private mode and Safari cross-origin iframes),
     * **this information may be wrong at initialization,**
     * as the storage could fallback from `indexedDB` to `localStorage`
     * only after a first read or write operation.
     * @returns Storage engine used
     *
     * @see {@link https://github.com/santoshyadavdev/ngx-pwa-offline/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'indexedDB') {}
     */
    get backingEngine() {
        if (this.database instanceof IndexedDBDatabase) {
            return 'indexedDB';
        }
        else if (this.database instanceof LocalStorageDatabase) {
            return 'localStorage';
        }
        else if (this.database instanceof MemoryDatabase) {
            return 'memory';
        }
        else {
            return 'unknown';
        }
    }
    /**
     * Info about `indexedDB` database. *Only useful for interoperability.*
     * @returns `indexedDB` database name, store name and database version.
     * **Values will be empty if the storage is not `indexedDB`,**
     * **so it should be used after an engine check**.
     *
     * @see {@link https://github.com/santoshyadavdev/ngx-pwa-offline/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'indexedDB') {
     *   const { database, store, version } = this.storageMap.backingStore;
     * }
     */
    get backingStore() {
        return (this.database instanceof IndexedDBDatabase) ?
            this.database.backingStore :
            { database: '', store: '', version: 0 };
    }
    /**
     * Info about `localStorage` fallback storage. *Only useful for interoperability.*
     * @returns `localStorage` prefix.
     * **Values will be empty if the storage is not `localStorage`,**
     * **so it should be used after an engine check**.
     *
     * @see {@link https://github.com/santoshyadavdev/ngx-pwa-offline/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'localStorage') {
     *   const { prefix } = this.storageMap.fallbackBackingStore;
     * }
     */
    get fallbackBackingStore() {
        return (this.database instanceof LocalStorageDatabase) ?
            { prefix: this.database.prefix } :
            { prefix: '' };
    }
    get(key, schema) {
        /* Get the data in storage */
        return this.database.get(key).pipe(
        /* Check if `indexedDb` is broken */
        this.catchIDBBroken(() => this.database.get(key)), mergeMap((data) => {
            /* No need to validate if the data is empty */
            if ((data === undefined) || (data === null)) {
                return of(undefined);
            }
            else if (schema) {
                /* Validate data against a JSON schema if provided */
                if (!this.jsonValidator.validate(data, schema)) {
                    return throwError(new ValidationError());
                }
                /* Data have been checked, so it's OK to cast */
                return of(data);
            }
            /* Cast to unknown as the data wasn't checked */
            return of(data);
        }));
    }
    /**
     * Set an item in storage.
     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.
     * @param key The item's key
     * @param data The item's value
     * @param schema Optional JSON schema to validate the data
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.set('key', 'value').subscribe(() => {});
     */
    set(key, data, schema) {
        /* Storing `undefined` or `null` is useless and can cause issues in `indexedDb` in some browsers,
         * so removing item instead for all storages to have a consistent API */
        if ((data === undefined) || (data === null)) {
            return this.delete(key);
        }
        /* Validate data against a JSON schema if provided */
        if (schema && !this.jsonValidator.validate(data, schema)) {
            return throwError(new ValidationError());
        }
        return this.database.set(key, data).pipe(
        /* Catch if `indexedDb` is broken */
        this.catchIDBBroken(() => this.database.set(key, data)), 
        /* Notify watchers (must be last because it should only happen if the operation succeeds) */
        tap(() => { this.notify(key, data); }));
    }
    /**
     * Delete an item in storage
     * @param key The item's key
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.delete('key').subscribe(() => {});
     */
    delete(key) {
        return this.database.delete(key).pipe(
        /* Catch if `indexedDb` is broken */
        this.catchIDBBroken(() => this.database.delete(key)), 
        /* Notify watchers (must be last because it should only happen if the operation succeeds) */
        tap(() => { this.notify(key, undefined); }));
    }
    /**
     * Delete all items in storage
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.clear().subscribe(() => {});
     */
    clear() {
        return this.database.clear().pipe(
        /* Catch if `indexedDb` is broken */
        this.catchIDBBroken(() => this.database.clear()), 
        /* Notify watchers (must be last because it should only happen if the operation succeeds) */
        tap(() => {
            for (const key of this.notifiers.keys()) {
                this.notify(key, undefined);
            }
        }));
    }
    /**
     * Get all keys stored in storage. Note **this is an *iterating* `Observable`**:
     * * if there is no key, the `next` callback will not be invoked,
     * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,
     * as this `Observable` can emit several values and so will invoke the `next` callback several times.
     * @returns A list of the keys wrapped in a RxJS `Observable`
     *
     * @example
     * this.storageMap.keys().subscribe({
     *   next: (key) => { console.log(key); },
     *   complete: () => { console.log('Done'); },
     * });
     */
    keys() {
        return this.database.keys()
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(() => this.database.keys()));
    }
    /**
     * Tells if a key exists in storage
     * @returns A RxJS `Observable` telling if the key exists
     *
     * @example
     * this.storageMap.has('key').subscribe((hasKey) => {
     *   if (hasKey) {}
     * });
     */
    has(key) {
        return this.database.has(key)
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(() => this.database.has(key)));
    }
    watch(key, schema) {
        /* Check if there is already a notifier */
        if (!this.notifiers.has(key)) {
            this.notifiers.set(key, new ReplaySubject(1));
        }
        /* Non-null assertion is required because TypeScript doesn't narrow `.has()` yet */
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const notifier = this.notifiers.get(key);
        /* Get the current item value */
        (schema ? this.get(key, schema) : this.get(key)).subscribe({
            next: (result) => notifier.next(result),
            error: (error) => notifier.error(error),
        });
        /* Only the public API of the `Observable` should be returned */
        return (schema ?
            notifier.asObservable() :
            notifier.asObservable());
    }
    /**
     * Notify when a value changes
     * @param key The item's key
     * @param data The new value
     */
    notify(key, value) {
        const notifier = this.notifiers.get(key);
        if (notifier) {
            notifier.next(value);
        }
    }
    /**
     * RxJS operator to catch if `indexedDB` is broken
     * @param operationCallback Callback with the operation to redo
     */
    catchIDBBroken(operationCallback) {
        return catchError((error) => {
            /* Check if `indexedDB` is broken based on error message (the specific error class seems to be lost in the process) */
            if ((error !== undefined) && (error !== null)
                && (typeof error === 'object') && ('message' in error)
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                && (error.message === IDB_BROKEN_ERROR)) {
                /* When storage is fully disabled in browser (via the "Block all cookies" option),
                 * just trying to check `localStorage` variable causes a security exception.
                 * Prevents https://github.com/santoshyadavdev/ngx-pwa-offline/issues/118
                 */
                try {
                    if ('getItem' in localStorage) {
                        /* Fallback to `localStorage` if available */
                        this.database = new LocalStorageDatabase(this.LSPrefix);
                    }
                    else {
                        /* Fallback to memory storage otherwise */
                        this.database = new MemoryDatabase();
                    }
                }
                catch {
                    /* Fallback to memory storage otherwise */
                    this.database = new MemoryDatabase();
                }
                /* Redo the operation */
                return operationCallback();
            }
            else {
                /* Otherwise, rethrow the error */
                return throwError(error);
            }
        });
    }
}
StorageMap.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.3", ngImport: i0, type: StorageMap, deps: [{ token: i1.LocalDatabase }, { token: i2.JSONValidator }, { token: LS_PREFIX }], target: i0.ɵɵFactoryTarget.Injectable });
StorageMap.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.3", ngImport: i0, type: StorageMap, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.3", ngImport: i0, type: StorageMap, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.LocalDatabase }, { type: i2.JSONValidator }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LS_PREFIX]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZS1tYXAuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1wd2EvbG9jYWwtc3RvcmFnZS9zcmMvbGliL3N0b3JhZ2VzL3N0b3JhZ2UtbWFwLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFjLFVBQVUsRUFBRSxFQUFFLEVBQW9CLGFBQWEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNuRixPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQU0zRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDN0QsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDcEUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDMUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBRTlELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQzNELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDdEMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGNBQWMsQ0FBQzs7OztBQUsvQyxNQUFNLE9BQU8sVUFBVTtJQUlyQjs7Ozs7T0FLRztJQUNILFlBQ1ksUUFBdUIsRUFDdkIsZ0JBQStCLElBQUksYUFBYSxFQUFFLEVBQy9CLFdBQVcsRUFBRTtRQUZoQyxhQUFRLEdBQVIsUUFBUSxDQUFlO1FBQ3ZCLGtCQUFhLEdBQWIsYUFBYSxDQUFxQztRQUMvQixhQUFRLEdBQVIsUUFBUSxDQUFLO1FBWGxDLGNBQVMsR0FBRyxJQUFJLEdBQUcsRUFBa0MsQ0FBQztJQVk3RCxDQUFDO0lBRUo7Ozs7Ozs7T0FPRztJQUNILElBQUksSUFBSTtRQUVOLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJO1lBQ3ZCLG9DQUFvQzthQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFFekQsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7O09BYUc7SUFDSCxJQUFJLGFBQWE7UUFFZixJQUFJLElBQUksQ0FBQyxRQUFRLFlBQVksaUJBQWlCLEVBQUU7WUFFOUMsT0FBTyxXQUFXLENBQUM7U0FFcEI7YUFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLFlBQVksb0JBQW9CLEVBQUU7WUFFeEQsT0FBTyxjQUFjLENBQUM7U0FFdkI7YUFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLFlBQVksY0FBYyxFQUFFO1lBRWxELE9BQU8sUUFBUSxDQUFDO1NBRWpCO2FBQU07WUFFTCxPQUFPLFNBQVMsQ0FBQztTQUVsQjtJQUVILENBQUM7SUFFRDs7Ozs7Ozs7Ozs7O09BWUc7SUFDSCxJQUFJLFlBQVk7UUFFZCxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsWUFBWSxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7WUFDbkQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUM1QixFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUM7SUFFNUMsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNILElBQUksb0JBQW9CO1FBRXRCLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxZQUFZLG9CQUFvQixDQUFDLENBQUMsQ0FBQztZQUN0RCxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFDbEMsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLENBQUM7SUFFbkIsQ0FBQztJQTRDRCxHQUFHLENBQWMsR0FBVyxFQUFFLE1BQW1CO1FBRS9DLDZCQUE2QjtRQUM3QixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUk7UUFDaEMsb0NBQW9DO1FBQ3BDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDakQsUUFBUSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFFaEIsOENBQThDO1lBQzlDLElBQUksQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLEVBQUU7Z0JBRTNDLE9BQU8sRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBRXRCO2lCQUFNLElBQUksTUFBTSxFQUFFO2dCQUVqQixxREFBcUQ7Z0JBQ3JELElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUU7b0JBQzlDLE9BQU8sVUFBVSxDQUFDLElBQUksZUFBZSxFQUFFLENBQUMsQ0FBQztpQkFDMUM7Z0JBRUQsZ0RBQWdEO2dCQUNoRCxPQUFPLEVBQUUsQ0FBQyxJQUFxQixDQUFDLENBQUM7YUFFbEM7WUFFRCxnREFBZ0Q7WUFDaEQsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFbEIsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUVKLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gsR0FBRyxDQUFDLEdBQVcsRUFBRSxJQUFhLEVBQUUsTUFBbUI7UUFFakQ7Z0ZBQ3dFO1FBQ3hFLElBQUksQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLEVBQUU7WUFDM0MsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3pCO1FBRUQscURBQXFEO1FBQ3JELElBQUksTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFO1lBQ3hELE9BQU8sVUFBVSxDQUFDLElBQUksZUFBZSxFQUFFLENBQUMsQ0FBQztTQUMxQztRQUVELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDLElBQUk7UUFDdEMsb0NBQW9DO1FBQ3BDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3ZELDRGQUE0RjtRQUM1RixHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDdkMsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsTUFBTSxDQUFDLEdBQVc7UUFFaEIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJO1FBQ25DLG9DQUFvQztRQUNwQyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3BELDRGQUE0RjtRQUM1RixHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDNUMsQ0FBQztJQUVKLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxLQUFLO1FBRUgsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDLElBQUk7UUFDL0Isb0NBQW9DO1FBQ3BDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNoRCw0RkFBNEY7UUFDNUYsR0FBRyxDQUFDLEdBQUcsRUFBRTtZQUNQLEtBQUssTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtnQkFDdkMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUM7YUFDN0I7UUFDSCxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBRUosQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNILElBQUk7UUFFRixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFO1lBQ3pCLG9DQUFvQzthQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztJQUUzRCxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCxHQUFHLENBQUMsR0FBVztRQUViLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1lBQzNCLG9DQUFvQzthQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFN0QsQ0FBQztJQW1CRCxLQUFLLENBQWMsR0FBVyxFQUFFLE1BQW1CO1FBRWpELDBDQUEwQztRQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDNUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDL0M7UUFFRCxtRkFBbUY7UUFDbkYsb0VBQW9FO1FBQ3BFLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBRSxDQUFDO1FBRTFDLGdDQUFnQztRQUNoQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBSSxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7WUFDNUQsSUFBSSxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUN2QyxLQUFLLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO1NBQ3hDLENBQUMsQ0FBQztRQUVILGdFQUFnRTtRQUNoRSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDZCxRQUFRLENBQUMsWUFBWSxFQUErQixDQUFDLENBQUM7WUFDdEQsUUFBUSxDQUFDLFlBQVksRUFBRSxDQUN4QixDQUFDO0lBRUosQ0FBQztJQUVEOzs7O09BSUc7SUFDTyxNQUFNLENBQUMsR0FBVyxFQUFFLEtBQWM7UUFFMUMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFekMsSUFBSSxRQUFRLEVBQUU7WUFDWixRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3RCO0lBRUgsQ0FBQztJQUVEOzs7T0FHRztJQUNPLGNBQWMsQ0FBSSxpQkFBc0M7UUFFaEUsT0FBTyxVQUFVLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUUxQixzSEFBc0g7WUFDdEgsSUFBSSxDQUFDLEtBQUssS0FBSyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUM7bUJBQzFDLENBQUMsT0FBTyxLQUFLLEtBQUssUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksS0FBSyxDQUFDO2dCQUN0RCxzRUFBc0U7bUJBQ25FLENBQUMsS0FBSyxDQUFDLE9BQU8sS0FBSyxnQkFBZ0IsQ0FBQyxFQUFFO2dCQUV2Qzs7O21CQUdHO2dCQUNILElBQUk7b0JBRUYsSUFBSSxTQUFTLElBQUksWUFBWSxFQUFFO3dCQUU3Qiw2Q0FBNkM7d0JBQzdDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7cUJBRXpEO3lCQUFNO3dCQUVMLDBDQUEwQzt3QkFDMUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO3FCQUV0QztpQkFFRjtnQkFBQyxNQUFNO29CQUVOLDBDQUEwQztvQkFDMUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO2lCQUV0QztnQkFFRCx3QkFBd0I7Z0JBQ3hCLE9BQU8saUJBQWlCLEVBQUUsQ0FBQzthQUU1QjtpQkFBTTtnQkFFTCxrQ0FBa0M7Z0JBQ2xDLE9BQU8sVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBRTFCO1FBRUgsQ0FBQyxDQUFDLENBQUM7SUFFTCxDQUFDOzt1R0FwWlUsVUFBVSw0RUFhWCxTQUFTOzJHQWJSLFVBQVUsY0FGVCxNQUFNOzJGQUVQLFVBQVU7a0JBSHRCLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25COzswQkFjSSxNQUFNOzJCQUFDLFNBQVMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIHRocm93RXJyb3IsIG9mLCBPcGVyYXRvckZ1bmN0aW9uLCBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtZXJnZU1hcCwgY2F0Y2hFcnJvciwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQge1xuICBKU09OU2NoZW1hLCBKU09OU2NoZW1hQm9vbGVhbiwgSlNPTlNjaGVtYUludGVnZXIsXG4gIEpTT05TY2hlbWFOdW1iZXIsIEpTT05TY2hlbWFTdHJpbmcsIEpTT05TY2hlbWFBcnJheU9mXG59IGZyb20gJy4uL3ZhbGlkYXRpb24vanNvbi1zY2hlbWEnO1xuaW1wb3J0IHsgSlNPTlZhbGlkYXRvciB9IGZyb20gJy4uL3ZhbGlkYXRpb24vanNvbi12YWxpZGF0b3InO1xuaW1wb3J0IHsgSW5kZXhlZERCRGF0YWJhc2UgfSBmcm9tICcuLi9kYXRhYmFzZXMvaW5kZXhlZGRiLWRhdGFiYXNlJztcbmltcG9ydCB7IExvY2FsU3RvcmFnZURhdGFiYXNlIH0gZnJvbSAnLi4vZGF0YWJhc2VzL2xvY2Fsc3RvcmFnZS1kYXRhYmFzZSc7XG5pbXBvcnQgeyBNZW1vcnlEYXRhYmFzZSB9IGZyb20gJy4uL2RhdGFiYXNlcy9tZW1vcnktZGF0YWJhc2UnO1xuaW1wb3J0IHsgTG9jYWxEYXRhYmFzZSB9IGZyb20gJy4uL2RhdGFiYXNlcy9sb2NhbC1kYXRhYmFzZSc7XG5pbXBvcnQgeyBJREJfQlJPS0VOX0VSUk9SIH0gZnJvbSAnLi4vZGF0YWJhc2VzL2V4Y2VwdGlvbnMnO1xuaW1wb3J0IHsgTFNfUFJFRklYIH0gZnJvbSAnLi4vdG9rZW5zJztcbmltcG9ydCB7IFZhbGlkYXRpb25FcnJvciB9IGZyb20gJy4vZXhjZXB0aW9ucyc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFN0b3JhZ2VNYXAge1xuXG4gIHByb3RlY3RlZCBub3RpZmllcnMgPSBuZXcgTWFwPHN0cmluZywgUmVwbGF5U3ViamVjdDx1bmtub3duPj4oKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IgcGFyYW1zIGFyZSBwcm92aWRlZCBieSBBbmd1bGFyIChidXQgY2FuIGFsc28gYmUgcGFzc2VkIG1hbnVhbGx5IGluIHRlc3RzKVxuICAgKiBAcGFyYW0gZGF0YWJhc2UgU3RvcmFnZSB0byB1c2VcbiAgICogQHBhcmFtIGpzb25WYWxpZGF0b3IgVmFsaWRhdG9yIHNlcnZpY2VcbiAgICogQHBhcmFtIExTUHJlZml4IFByZWZpeCBmb3IgYGxvY2FsU3RvcmFnZWAga2V5cyB0byBhdm9pZCBjb2xsaXNpb24gZm9yIG11bHRpcGxlIGFwcHMgb24gdGhlIHNhbWUgc3ViZG9tYWluIG9yIGZvciBpbnRlcm9wZXJhYmlsaXR5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgZGF0YWJhc2U6IExvY2FsRGF0YWJhc2UsXG4gICAgcHJvdGVjdGVkIGpzb25WYWxpZGF0b3I6IEpTT05WYWxpZGF0b3IgPSBuZXcgSlNPTlZhbGlkYXRvcigpLFxuICAgIEBJbmplY3QoTFNfUFJFRklYKSBwcm90ZWN0ZWQgTFNQcmVmaXggPSAnJyxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiAqKk51bWJlciBvZiBpdGVtcyoqIGluIHN0b3JhZ2UsIHdyYXBwZWQgaW4gYW4gYE9ic2VydmFibGVgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuc2l6ZS5zdWJzY3JpYmUoKHNpemUpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhzaXplKTtcbiAgICogfSk7XG4gICAqL1xuICBnZXQgc2l6ZSgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2Uuc2l6ZVxuICAgICAgLyogQ2F0Y2ggaWYgYGluZGV4ZWREYmAgaXMgYnJva2VuICovXG4gICAgICAucGlwZSh0aGlzLmNhdGNoSURCQnJva2VuKCgpID0+IHRoaXMuZGF0YWJhc2Uuc2l6ZSkpO1xuXG4gIH1cblxuICAvKipcbiAgICogVGVsbHMgeW91IHdoaWNoIHN0b3JhZ2UgZW5naW5lIGlzIHVzZWQuICpPbmx5IHVzZWZ1bCBmb3IgaW50ZXJvcGVyYWJpbGl0eS4qXG4gICAqIE5vdGUgdGhhdCBkdWUgdG8gc29tZSBicm93c2VycyBpc3N1ZXMgaW4gc29tZSBzcGVjaWFsIGNvbnRleHRzXG4gICAqIChGaXJlZm94IHByaXZhdGUgbW9kZSBhbmQgU2FmYXJpIGNyb3NzLW9yaWdpbiBpZnJhbWVzKSxcbiAgICogKip0aGlzIGluZm9ybWF0aW9uIG1heSBiZSB3cm9uZyBhdCBpbml0aWFsaXphdGlvbiwqKlxuICAgKiBhcyB0aGUgc3RvcmFnZSBjb3VsZCBmYWxsYmFjayBmcm9tIGBpbmRleGVkREJgIHRvIGBsb2NhbFN0b3JhZ2VgXG4gICAqIG9ubHkgYWZ0ZXIgYSBmaXJzdCByZWFkIG9yIHdyaXRlIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMgU3RvcmFnZSBlbmdpbmUgdXNlZFxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc2FudG9zaHlhZGF2ZGV2L25neC1wd2Etb2ZmbGluZS9ibG9iL21haW4vZG9jcy9JTlRFUk9QRVJBQklMSVRZLm1kfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpZiAodGhpcy5zdG9yYWdlTWFwLmJhY2tpbmdFbmdpbmUgPT09ICdpbmRleGVkREInKSB7fVxuICAgKi9cbiAgZ2V0IGJhY2tpbmdFbmdpbmUoKTogJ2luZGV4ZWREQicgfCAnbG9jYWxTdG9yYWdlJyB8ICdtZW1vcnknIHwgJ3Vua25vd24nIHtcblxuICAgIGlmICh0aGlzLmRhdGFiYXNlIGluc3RhbmNlb2YgSW5kZXhlZERCRGF0YWJhc2UpIHtcblxuICAgICAgcmV0dXJuICdpbmRleGVkREInO1xuXG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGFiYXNlIGluc3RhbmNlb2YgTG9jYWxTdG9yYWdlRGF0YWJhc2UpIHtcblxuICAgICAgcmV0dXJuICdsb2NhbFN0b3JhZ2UnO1xuXG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGFiYXNlIGluc3RhbmNlb2YgTWVtb3J5RGF0YWJhc2UpIHtcblxuICAgICAgcmV0dXJuICdtZW1vcnknO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuICd1bmtub3duJztcblxuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIEluZm8gYWJvdXQgYGluZGV4ZWREQmAgZGF0YWJhc2UuICpPbmx5IHVzZWZ1bCBmb3IgaW50ZXJvcGVyYWJpbGl0eS4qXG4gICAqIEByZXR1cm5zIGBpbmRleGVkREJgIGRhdGFiYXNlIG5hbWUsIHN0b3JlIG5hbWUgYW5kIGRhdGFiYXNlIHZlcnNpb24uXG4gICAqICoqVmFsdWVzIHdpbGwgYmUgZW1wdHkgaWYgdGhlIHN0b3JhZ2UgaXMgbm90IGBpbmRleGVkREJgLCoqXG4gICAqICoqc28gaXQgc2hvdWxkIGJlIHVzZWQgYWZ0ZXIgYW4gZW5naW5lIGNoZWNrKiouXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW50b3NoeWFkYXZkZXYvbmd4LXB3YS1vZmZsaW5lL2Jsb2IvbWFpbi9kb2NzL0lOVEVST1BFUkFCSUxJVFkubWR9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGlmICh0aGlzLnN0b3JhZ2VNYXAuYmFja2luZ0VuZ2luZSA9PT0gJ2luZGV4ZWREQicpIHtcbiAgICogICBjb25zdCB7IGRhdGFiYXNlLCBzdG9yZSwgdmVyc2lvbiB9ID0gdGhpcy5zdG9yYWdlTWFwLmJhY2tpbmdTdG9yZTtcbiAgICogfVxuICAgKi9cbiAgZ2V0IGJhY2tpbmdTdG9yZSgpOiB7IGRhdGFiYXNlOiBzdHJpbmcsIHN0b3JlOiBzdHJpbmcsIHZlcnNpb246IG51bWJlciB9IHtcblxuICAgIHJldHVybiAodGhpcy5kYXRhYmFzZSBpbnN0YW5jZW9mIEluZGV4ZWREQkRhdGFiYXNlKSA/XG4gICAgICB0aGlzLmRhdGFiYXNlLmJhY2tpbmdTdG9yZSA6XG4gICAgICB7IGRhdGFiYXNlOiAnJywgc3RvcmU6ICcnLCB2ZXJzaW9uOiAwIH07XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmZvIGFib3V0IGBsb2NhbFN0b3JhZ2VgIGZhbGxiYWNrIHN0b3JhZ2UuICpPbmx5IHVzZWZ1bCBmb3IgaW50ZXJvcGVyYWJpbGl0eS4qXG4gICAqIEByZXR1cm5zIGBsb2NhbFN0b3JhZ2VgIHByZWZpeC5cbiAgICogKipWYWx1ZXMgd2lsbCBiZSBlbXB0eSBpZiB0aGUgc3RvcmFnZSBpcyBub3QgYGxvY2FsU3RvcmFnZWAsKipcbiAgICogKipzbyBpdCBzaG91bGQgYmUgdXNlZCBhZnRlciBhbiBlbmdpbmUgY2hlY2sqKi5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3NhbnRvc2h5YWRhdmRldi9uZ3gtcHdhLW9mZmxpbmUvYmxvYi9tYWluL2RvY3MvSU5URVJPUEVSQUJJTElUWS5tZH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaWYgKHRoaXMuc3RvcmFnZU1hcC5iYWNraW5nRW5naW5lID09PSAnbG9jYWxTdG9yYWdlJykge1xuICAgKiAgIGNvbnN0IHsgcHJlZml4IH0gPSB0aGlzLnN0b3JhZ2VNYXAuZmFsbGJhY2tCYWNraW5nU3RvcmU7XG4gICAqIH1cbiAgICovXG4gIGdldCBmYWxsYmFja0JhY2tpbmdTdG9yZSgpOiB7IHByZWZpeDogc3RyaW5nIH0ge1xuXG4gICAgcmV0dXJuICh0aGlzLmRhdGFiYXNlIGluc3RhbmNlb2YgTG9jYWxTdG9yYWdlRGF0YWJhc2UpID9cbiAgICAgIHsgcHJlZml4OiB0aGlzLmRhdGFiYXNlLnByZWZpeCB9IDpcbiAgICAgIHsgcHJlZml4OiAnJyB9O1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGl0ZW0gdmFsdWUgaW4gc3RvcmFnZS5cbiAgICogVGhlIHNpZ25hdHVyZSBoYXMgbWFueSBvdmVybG9hZHMgZHVlIHRvIHZhbGlkYXRpb24sICoqcGxlYXNlIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uLioqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW50b3NoeWFkYXZkZXYvbmd4LXB3YS1vZmZsaW5lL2Jsb2IvbWFpbi9kb2NzL1ZBTElEQVRJT04ubWR9XG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHBhcmFtIHNjaGVtYSBPcHRpb25hbCBKU09OIHNjaGVtYSB0byB2YWxpZGF0ZSB0aGUgZGF0YVxuICAgKiBAcmV0dXJucyBUaGUgaXRlbSdzIHZhbHVlIGlmIHRoZSBrZXkgZXhpc3RzLCBgdW5kZWZpbmVkYCBvdGhlcndpc2UsIHdyYXBwZWQgaW4gYSBSeEpTIGBPYnNlcnZhYmxlYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuZ2V0KCdrZXknLCB7IHR5cGU6ICdzdHJpbmcnIH0pLnN1YnNjcmliZSgocmVzdWx0KSA9PiB7XG4gICAqICAgcmVzdWx0OyAvLyBzdHJpbmcgb3IgdW5kZWZpbmVkXG4gICAqIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbnRlcmZhY2UgVXNlciB7XG4gICAqICAgZmlyc3ROYW1lOiBzdHJpbmc7XG4gICAqICAgbGFzdE5hbWU/OiBzdHJpbmc7XG4gICAqIH1cbiAgICpcbiAgICogY29uc3Qgc2NoZW1hID0ge1xuICAgKiAgIHR5cGU6ICdvYmplY3QnLFxuICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICogICAgIGZpcnN0TmFtZTogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgKiAgICAgbGFzdE5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICogICB9LFxuICAgKiAgIHJlcXVpcmVkOiBbJ2ZpcnN0TmFtZSddXG4gICAqIH07XG4gICAqXG4gICAqIHRoaXMuc3RvcmFnZU1hcC5nZXQ8VXNlcj4oJ3VzZXInLCBzY2hlbWEpLnN1YnNjcmliZSgodXNlcikgPT4ge1xuICAgKiAgIGlmICh1c2VyKSB7XG4gICAqICAgICB1c2VyLmZpcnN0TmFtZTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKi9cbiAgZ2V0KGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTx1bmtub3duPjtcbiAgZ2V0PFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFTdHJpbmcpOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICBnZXQ8VCBleHRlbmRzIG51bWJlciA9IG51bWJlcj4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUludGVnZXIgfCBKU09OU2NoZW1hTnVtYmVyKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgZ2V0PFQgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbj4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUJvb2xlYW4pOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICBnZXQ8VCBleHRlbmRzIHJlYWRvbmx5IHN0cmluZ1tdID0gc3RyaW5nW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFTdHJpbmc+KTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgZ2V0PFQgZXh0ZW5kcyByZWFkb25seSBudW1iZXJbXSA9IG51bWJlcltdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hSW50ZWdlciB8IEpTT05TY2hlbWFOdW1iZXI+KTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG4gIGdldDxUIGV4dGVuZHMgcmVhZG9ubHkgYm9vbGVhbltdID0gYm9vbGVhbltdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hQm9vbGVhbj4pOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICBnZXQ8VD4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYSk6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIGdldDxUID0gdW5rbm93bj4oa2V5OiBzdHJpbmcsIHNjaGVtYT86IEpTT05TY2hlbWEpOiBPYnNlcnZhYmxlPHVua25vd24+IHtcblxuICAgIC8qIEdldCB0aGUgZGF0YSBpbiBzdG9yYWdlICovXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2UuZ2V0KGtleSkucGlwZShcbiAgICAgIC8qIENoZWNrIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgdGhpcy5jYXRjaElEQkJyb2tlbigoKSA9PiB0aGlzLmRhdGFiYXNlLmdldChrZXkpKSxcbiAgICAgIG1lcmdlTWFwKChkYXRhKSA9PiB7XG5cbiAgICAgICAgLyogTm8gbmVlZCB0byB2YWxpZGF0ZSBpZiB0aGUgZGF0YSBpcyBlbXB0eSAqL1xuICAgICAgICBpZiAoKGRhdGEgPT09IHVuZGVmaW5lZCkgfHwgKGRhdGEgPT09IG51bGwpKSB7XG5cbiAgICAgICAgICByZXR1cm4gb2YodW5kZWZpbmVkKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYSkge1xuXG4gICAgICAgICAgLyogVmFsaWRhdGUgZGF0YSBhZ2FpbnN0IGEgSlNPTiBzY2hlbWEgaWYgcHJvdmlkZWQgKi9cbiAgICAgICAgICBpZiAoIXRoaXMuanNvblZhbGlkYXRvci52YWxpZGF0ZShkYXRhLCBzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgVmFsaWRhdGlvbkVycm9yKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qIERhdGEgaGF2ZSBiZWVuIGNoZWNrZWQsIHNvIGl0J3MgT0sgdG8gY2FzdCAqL1xuICAgICAgICAgIHJldHVybiBvZihkYXRhIGFzIFQgfCB1bmRlZmluZWQpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvKiBDYXN0IHRvIHVua25vd24gYXMgdGhlIGRhdGEgd2Fzbid0IGNoZWNrZWQgKi9cbiAgICAgICAgcmV0dXJuIG9mKGRhdGEpO1xuXG4gICAgICB9KSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogU2V0IGFuIGl0ZW0gaW4gc3RvcmFnZS5cbiAgICogTm90ZSB0aGF0IHNldHRpbmcgYG51bGxgIG9yIGB1bmRlZmluZWRgIHdpbGwgcmVtb3ZlIHRoZSBpdGVtIHRvIGF2b2lkIHNvbWUgYnJvd3NlcnMgaXNzdWVzLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBkYXRhIFRoZSBpdGVtJ3MgdmFsdWVcbiAgICogQHBhcmFtIHNjaGVtYSBPcHRpb25hbCBKU09OIHNjaGVtYSB0byB2YWxpZGF0ZSB0aGUgZGF0YVxuICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMuc3RvcmFnZU1hcC5zZXQoJ2tleScsICd2YWx1ZScpLnN1YnNjcmliZSgoKSA9PiB7fSk7XG4gICAqL1xuICBzZXQoa2V5OiBzdHJpbmcsIGRhdGE6IHVua25vd24sIHNjaGVtYT86IEpTT05TY2hlbWEpOiBPYnNlcnZhYmxlPHVuZGVmaW5lZD4ge1xuXG4gICAgLyogU3RvcmluZyBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaXMgdXNlbGVzcyBhbmQgY2FuIGNhdXNlIGlzc3VlcyBpbiBgaW5kZXhlZERiYCBpbiBzb21lIGJyb3dzZXJzLFxuICAgICAqIHNvIHJlbW92aW5nIGl0ZW0gaW5zdGVhZCBmb3IgYWxsIHN0b3JhZ2VzIHRvIGhhdmUgYSBjb25zaXN0ZW50IEFQSSAqL1xuICAgIGlmICgoZGF0YSA9PT0gdW5kZWZpbmVkKSB8fCAoZGF0YSA9PT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuICAgIH1cblxuICAgIC8qIFZhbGlkYXRlIGRhdGEgYWdhaW5zdCBhIEpTT04gc2NoZW1hIGlmIHByb3ZpZGVkICovXG4gICAgaWYgKHNjaGVtYSAmJiAhdGhpcy5qc29uVmFsaWRhdG9yLnZhbGlkYXRlKGRhdGEsIHNjaGVtYSkpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yKG5ldyBWYWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2Uuc2V0KGtleSwgZGF0YSkucGlwZShcbiAgICAgIC8qIENhdGNoIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgdGhpcy5jYXRjaElEQkJyb2tlbigoKSA9PiB0aGlzLmRhdGFiYXNlLnNldChrZXksIGRhdGEpKSxcbiAgICAgIC8qIE5vdGlmeSB3YXRjaGVycyAobXVzdCBiZSBsYXN0IGJlY2F1c2UgaXQgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZSBvcGVyYXRpb24gc3VjY2VlZHMpICovXG4gICAgICB0YXAoKCkgPT4geyB0aGlzLm5vdGlmeShrZXksIGRhdGEpOyB9KSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbiBpdGVtIGluIHN0b3JhZ2VcbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMuc3RvcmFnZU1hcC5kZWxldGUoJ2tleScpLnN1YnNjcmliZSgoKSA9PiB7fSk7XG4gICAqL1xuICBkZWxldGUoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPHVuZGVmaW5lZD4ge1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2UuZGVsZXRlKGtleSkucGlwZShcbiAgICAgIC8qIENhdGNoIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgdGhpcy5jYXRjaElEQkJyb2tlbigoKSA9PiB0aGlzLmRhdGFiYXNlLmRlbGV0ZShrZXkpKSxcbiAgICAgIC8qIE5vdGlmeSB3YXRjaGVycyAobXVzdCBiZSBsYXN0IGJlY2F1c2UgaXQgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZSBvcGVyYXRpb24gc3VjY2VlZHMpICovXG4gICAgICB0YXAoKCkgPT4geyB0aGlzLm5vdGlmeShrZXksIHVuZGVmaW5lZCk7IH0pLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYWxsIGl0ZW1zIGluIHN0b3JhZ2VcbiAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuY2xlYXIoKS5zdWJzY3JpYmUoKCkgPT4ge30pO1xuICAgKi9cbiAgY2xlYXIoKTogT2JzZXJ2YWJsZTx1bmRlZmluZWQ+IHtcblxuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlLmNsZWFyKCkucGlwZShcbiAgICAgIC8qIENhdGNoIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgdGhpcy5jYXRjaElEQkJyb2tlbigoKSA9PiB0aGlzLmRhdGFiYXNlLmNsZWFyKCkpLFxuICAgICAgLyogTm90aWZ5IHdhdGNoZXJzIChtdXN0IGJlIGxhc3QgYmVjYXVzZSBpdCBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlIG9wZXJhdGlvbiBzdWNjZWVkcykgKi9cbiAgICAgIHRhcCgoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMubm90aWZpZXJzLmtleXMoKSkge1xuICAgICAgICAgIHRoaXMubm90aWZ5KGtleSwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwga2V5cyBzdG9yZWQgaW4gc3RvcmFnZS4gTm90ZSAqKnRoaXMgaXMgYW4gKml0ZXJhdGluZyogYE9ic2VydmFibGVgKio6XG4gICAqICogaWYgdGhlcmUgaXMgbm8ga2V5LCB0aGUgYG5leHRgIGNhbGxiYWNrIHdpbGwgbm90IGJlIGludm9rZWQsXG4gICAqICogaWYgeW91IG5lZWQgdG8gd2FpdCB0aGUgd2hvbGUgb3BlcmF0aW9uIHRvIGVuZCwgYmUgc3VyZSB0byBhY3QgaW4gdGhlIGBjb21wbGV0ZWAgY2FsbGJhY2ssXG4gICAqIGFzIHRoaXMgYE9ic2VydmFibGVgIGNhbiBlbWl0IHNldmVyYWwgdmFsdWVzIGFuZCBzbyB3aWxsIGludm9rZSB0aGUgYG5leHRgIGNhbGxiYWNrIHNldmVyYWwgdGltZXMuXG4gICAqIEByZXR1cm5zIEEgbGlzdCBvZiB0aGUga2V5cyB3cmFwcGVkIGluIGEgUnhKUyBgT2JzZXJ2YWJsZWBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5zdG9yYWdlTWFwLmtleXMoKS5zdWJzY3JpYmUoe1xuICAgKiAgIG5leHQ6IChrZXkpID0+IHsgY29uc29sZS5sb2coa2V5KTsgfSxcbiAgICogICBjb21wbGV0ZTogKCkgPT4geyBjb25zb2xlLmxvZygnRG9uZScpOyB9LFxuICAgKiB9KTtcbiAgICovXG4gIGtleXMoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblxuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlLmtleXMoKVxuICAgICAgLyogQ2F0Y2ggaWYgYGluZGV4ZWREYmAgaXMgYnJva2VuICovXG4gICAgICAucGlwZSh0aGlzLmNhdGNoSURCQnJva2VuKCgpID0+IHRoaXMuZGF0YWJhc2Uua2V5cygpKSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBUZWxscyBpZiBhIGtleSBleGlzdHMgaW4gc3RvcmFnZVxuICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIHRlbGxpbmcgaWYgdGhlIGtleSBleGlzdHNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5zdG9yYWdlTWFwLmhhcygna2V5Jykuc3Vic2NyaWJlKChoYXNLZXkpID0+IHtcbiAgICogICBpZiAoaGFzS2V5KSB7fVxuICAgKiB9KTtcbiAgICovXG4gIGhhcyhrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2UuaGFzKGtleSlcbiAgICAgIC8qIENhdGNoIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgLnBpcGUodGhpcy5jYXRjaElEQkJyb2tlbigoKSA9PiB0aGlzLmRhdGFiYXNlLmhhcyhrZXkpKSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBXYXRjaCBhbiBpdGVtIHZhbHVlIGluIHN0b3JhZ2UuXG4gICAqICoqTm90ZSBvbmx5IGNoYW5nZXMgZG9uZSB2aWEgdGhpcyBsaWIgd2lsbCBiZSB3YXRjaGVkKiosIGV4dGVybmFsIGNoYW5nZXMgaW4gc3RvcmFnZSBjYW4ndCBiZSBkZXRlY3RlZC5cbiAgICogVGhlIHNpZ25hdHVyZSBoYXMgbWFueSBvdmVybG9hZHMgZHVlIHRvIHZhbGlkYXRpb24sICoqcGxlYXNlIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uLioqXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3NhbnRvc2h5YWRhdmRldi9uZ3gtcHdhLW9mZmxpbmUvYmxvYi9tYWluL2RvY3MvVkFMSURBVElPTi5tZFxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5IHRvIHdhdGNoXG4gICAqIEBwYXJhbSBzY2hlbWEgT3B0aW9uYWwgSlNPTiBzY2hlbWEgdG8gdmFsaWRhdGUgdGhlIGluaXRpYWwgdmFsdWVcbiAgICogQHJldHVybnMgQW4gaW5maW5pdGUgYE9ic2VydmFibGVgIGdpdmluZyB0aGUgY3VycmVudCB2YWx1ZVxuICAgKi9cbiAgd2F0Y2goa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPHVua25vd24+O1xuICB3YXRjaDxUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hU3RyaW5nKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgd2F0Y2g8VCBleHRlbmRzIG51bWJlciA9IG51bWJlcj4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUludGVnZXIgfCBKU09OU2NoZW1hTnVtYmVyKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgd2F0Y2g8VCBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQm9vbGVhbik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIHdhdGNoPFQgZXh0ZW5kcyByZWFkb25seSBzdHJpbmdbXSA9IHN0cmluZ1tdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hU3RyaW5nPik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIHdhdGNoPFQgZXh0ZW5kcyByZWFkb25seSBudW1iZXJbXSA9IG51bWJlcltdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hSW50ZWdlciB8IEpTT05TY2hlbWFOdW1iZXI+KTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG4gIHdhdGNoPFQgZXh0ZW5kcyByZWFkb25seSBib29sZWFuW10gPSBib29sZWFuW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFCb29sZWFuPik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIHdhdGNoPFQ+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWEpOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICB3YXRjaDxUID0gdW5rbm93bj4oa2V5OiBzdHJpbmcsIHNjaGVtYT86IEpTT05TY2hlbWEpOiBPYnNlcnZhYmxlPHVua25vd24+IHtcblxuICAgIC8qIENoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBub3RpZmllciAqL1xuICAgIGlmICghdGhpcy5ub3RpZmllcnMuaGFzKGtleSkpIHtcbiAgICAgIHRoaXMubm90aWZpZXJzLnNldChrZXksIG5ldyBSZXBsYXlTdWJqZWN0KDEpKTtcbiAgICB9XG5cbiAgICAvKiBOb24tbnVsbCBhc3NlcnRpb24gaXMgcmVxdWlyZWQgYmVjYXVzZSBUeXBlU2NyaXB0IGRvZXNuJ3QgbmFycm93IGAuaGFzKClgIHlldCAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgY29uc3Qgbm90aWZpZXIgPSB0aGlzLm5vdGlmaWVycy5nZXQoa2V5KSE7XG5cbiAgICAvKiBHZXQgdGhlIGN1cnJlbnQgaXRlbSB2YWx1ZSAqL1xuICAgIChzY2hlbWEgPyB0aGlzLmdldDxUPihrZXksIHNjaGVtYSkgOiB0aGlzLmdldChrZXkpKS5zdWJzY3JpYmUoe1xuICAgICAgbmV4dDogKHJlc3VsdCkgPT4gbm90aWZpZXIubmV4dChyZXN1bHQpLFxuICAgICAgZXJyb3I6IChlcnJvcikgPT4gbm90aWZpZXIuZXJyb3IoZXJyb3IpLFxuICAgIH0pO1xuXG4gICAgLyogT25seSB0aGUgcHVibGljIEFQSSBvZiB0aGUgYE9ic2VydmFibGVgIHNob3VsZCBiZSByZXR1cm5lZCAqL1xuICAgIHJldHVybiAoc2NoZW1hID9cbiAgICAgIG5vdGlmaWVyLmFzT2JzZXJ2YWJsZSgpIGFzIE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD4gOlxuICAgICAgbm90aWZpZXIuYXNPYnNlcnZhYmxlKClcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogTm90aWZ5IHdoZW4gYSB2YWx1ZSBjaGFuZ2VzXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHBhcmFtIGRhdGEgVGhlIG5ldyB2YWx1ZVxuICAgKi9cbiAgcHJvdGVjdGVkIG5vdGlmeShrZXk6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiB2b2lkIHtcblxuICAgIGNvbnN0IG5vdGlmaWVyID0gdGhpcy5ub3RpZmllcnMuZ2V0KGtleSk7XG5cbiAgICBpZiAobm90aWZpZXIpIHtcbiAgICAgIG5vdGlmaWVyLm5leHQodmFsdWUpO1xuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIFJ4SlMgb3BlcmF0b3IgdG8gY2F0Y2ggaWYgYGluZGV4ZWREQmAgaXMgYnJva2VuXG4gICAqIEBwYXJhbSBvcGVyYXRpb25DYWxsYmFjayBDYWxsYmFjayB3aXRoIHRoZSBvcGVyYXRpb24gdG8gcmVkb1xuICAgKi9cbiAgcHJvdGVjdGVkIGNhdGNoSURCQnJva2VuPFQ+KG9wZXJhdGlvbkNhbGxiYWNrOiAoKSA9PiBPYnNlcnZhYmxlPFQ+KTogT3BlcmF0b3JGdW5jdGlvbjxULCBUPiB7XG5cbiAgICByZXR1cm4gY2F0Y2hFcnJvcigoZXJyb3IpID0+IHtcblxuICAgICAgLyogQ2hlY2sgaWYgYGluZGV4ZWREQmAgaXMgYnJva2VuIGJhc2VkIG9uIGVycm9yIG1lc3NhZ2UgKHRoZSBzcGVjaWZpYyBlcnJvciBjbGFzcyBzZWVtcyB0byBiZSBsb3N0IGluIHRoZSBwcm9jZXNzKSAqL1xuICAgICAgaWYgKChlcnJvciAhPT0gdW5kZWZpbmVkKSAmJiAoZXJyb3IgIT09IG51bGwpXG4gICAgICAmJiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JykgJiYgKCdtZXNzYWdlJyBpbiBlcnJvcilcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICYmIChlcnJvci5tZXNzYWdlID09PSBJREJfQlJPS0VOX0VSUk9SKSkge1xuXG4gICAgICAgIC8qIFdoZW4gc3RvcmFnZSBpcyBmdWxseSBkaXNhYmxlZCBpbiBicm93c2VyICh2aWEgdGhlIFwiQmxvY2sgYWxsIGNvb2tpZXNcIiBvcHRpb24pLFxuICAgICAgICAgKiBqdXN0IHRyeWluZyB0byBjaGVjayBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSBjYXVzZXMgYSBzZWN1cml0eSBleGNlcHRpb24uXG4gICAgICAgICAqIFByZXZlbnRzIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW50b3NoeWFkYXZkZXYvbmd4LXB3YS1vZmZsaW5lL2lzc3Vlcy8xMThcbiAgICAgICAgICovXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICBpZiAoJ2dldEl0ZW0nIGluIGxvY2FsU3RvcmFnZSkge1xuXG4gICAgICAgICAgICAvKiBGYWxsYmFjayB0byBgbG9jYWxTdG9yYWdlYCBpZiBhdmFpbGFibGUgKi9cbiAgICAgICAgICAgIHRoaXMuZGF0YWJhc2UgPSBuZXcgTG9jYWxTdG9yYWdlRGF0YWJhc2UodGhpcy5MU1ByZWZpeCk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvKiBGYWxsYmFjayB0byBtZW1vcnkgc3RvcmFnZSBvdGhlcndpc2UgKi9cbiAgICAgICAgICAgIHRoaXMuZGF0YWJhc2UgPSBuZXcgTWVtb3J5RGF0YWJhc2UoKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9IGNhdGNoIHtcblxuICAgICAgICAgIC8qIEZhbGxiYWNrIHRvIG1lbW9yeSBzdG9yYWdlIG90aGVyd2lzZSAqL1xuICAgICAgICAgIHRoaXMuZGF0YWJhc2UgPSBuZXcgTWVtb3J5RGF0YWJhc2UoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLyogUmVkbyB0aGUgb3BlcmF0aW9uICovXG4gICAgICAgIHJldHVybiBvcGVyYXRpb25DYWxsYmFjaygpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8qIE90aGVyd2lzZSwgcmV0aHJvdyB0aGUgZXJyb3IgKi9cbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZXJyb3IpO1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbn1cbiJdfQ==